Joining and clipping
========================================================

This tutorial builds on the previous section on plotting and highlights 
some of R's more advanced spatial functions. We look at joining new 
datasets to our data - an attribute join - spatial joins, whereby 
data is added to the target layer depending on the location of the 
origins and clipping. 

## Joining based on attributes
To reaffirm our starting point, let's re-plot the only 
spatial dataset in our workspace, and count the number
of polygons:
```{r}
library(rgdal)
lnd <- readOGR(dsn = ".", "london_sport")
plot(lnd)
nrow(lnd)
```

### Downloading additional data
Because we are using borough-level data, and boroughs are official administrative
zones, there is much data available at this level. We will use the example 
of crime data to illustrate this data availability, and join this with the current 
spatial dataset. As before, we can download and import the data from within R:
```{r}
# download.file("http://data.london.gov.uk/datafiles/crime-community-safety/mps-recordedcrime-borough.csv", destfile = "mps-recordedcrime-borough.csv")
# uncomment the above line of code to download the data

crimeDat <- read.csv("mps-recordedcrime-borough.csv") # flags an error
```
Initially, the `read.csv` command flags an error: open the raw .csv file in a 
text editor such as Notepad, Notepad++ or GVIM, find the problem and correct it.
Alternatively, you can work out what the file encoding is and use the correct 
argument (this is not recommended - simpler just to edit the text file
in most cases).

```{r}
crimeDat <- read.csv("mps-recordedcrime-borough.csv", fileEncoding = "UCS-2LE")
head(crimeDat)
summary(crimeDat$MajorText)
crimeTheft <- crimeDat[which(crimeDat$MajorText == "Theft & Handling"), ]
head(crimeTheft)
crimeAg <- aggregate(CrimeCount ~ Spatial_DistrictName, FUN = "sum", 
                     data = crimeTheft)
head(crimeAg) # show the aggregated crime data
```
Now that we have crime data at the borough level, the challenge is to join it
by name. This is not always straightforward. Let us see which names in the 
crime data match the spatial data:
```{r}
lnd$name %in% crimeAg$Spatial_DistrictName 
lnd$name[which(!lnd$name %in% crimeAg$Spatial_DistrictName)]
```
The first line of code above shows that all but one of the borough names matches;
the second tells us that it is City of London that is named differently in the 
crime data:
```{r}
levels(crimeAg$Spatial_DistrictName)
levels(crimeAg$Spatial_DistrictName)[25] <- 
  as.character(lnd$name[which(!lnd$name %in% crimeAg$Spatial_DistrictName)])
lnd$name %in% crimeAg$Spatial_DistrictName # now all columns match
```
The above code block first identified the row with the faulty name and 
then renamed the level to match the `lnd` dataset. Note that we could not
rename the variable directly, as it is stored as a factor.

We are now ready to join the datasets. It is recommended to use 
the `join` function in the `plyr` package but the `merge` function 
could equally be used.
```{r}
?join
library(plyr)
?join
```
The documentation for join will be displayed if the plyr package is loaded (if not,
load or install and load it!). It requires all joining variables to have the 
same name, so we will rename the variable to make the join work:
```{r}
head(lnd$name)
head(crimeAg$Spatial_DistrictName) # the variables to join
crimeAg <- rename(crimeAg, replace = c("Spatial_DistrictName" = "name"))
head(join(lnd@data, crimeAg)) # test it works
lnd@data <- join(lnd@data, crimeAg)
```

## Spatial joins
In addition to joing by zone name, it is also possible to do
[spatial joins](http://help.arcgis.com/en/arcgisdesktop/10.0/help/index.html#//00080000000q000000) in R. There are three main varieties: many-to-one - where
the values of many intersecting objects contribute to a new variable in 
the main table - one-to-many, or one-to-one. Because boroughs in London 
are quite large, we will conduct a many-to-one spatial join.
We will be using Tube Stations as the spatial data to join, 
with the aim of finding out which and how many stations
are found in each London borough.
```{r}
download.file()
library(rgdal)
stations <- readOGR(dsn = ".", layer = "lnd-stns", p4s="+init=epsg:27700")
proj4string(stations) # this is the full geographical detail.
proj4string(lnd)
bbox(stations)
bbox(lnd)
```
The above code loads the data correctly, but also shows that 
there are problems with it: the Coordinate Reference System (CRS)
differs from that of our shapefile. 
Although OSGB 1936 (or EPSG 27700) is the 'correct' CRS for the UK, 
we will convert the stations dataset into lat-long coordinates, 
as this is a more common CRS and enables easy basemap creation:
 
```{r}
stationsWGS <- spTransform(stations, CRSobj = CRS("+init=epsg:4326"))
stations <- stationsWGS; rm(stationsWGS)
plot(lnd)
points(stations[sample(1:nrow(stations), size = 500),])
```

Now we can clearly see that the stations overlay the boroughs.
The problem is that the stations dataset is far more exentsive than
London borough dataset; we need 


## Clipping
